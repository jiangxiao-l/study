#  Rest Formwork_序列化组件

## 一、实现序列化的方式

```python
'''
1. drf中的序列化组件与django中的forms组件很相似。
2. 不仅有序列化的功能，而且还有保存和更新的功能
3. 但是，功能性越好，其局限性就越强。 
'''



1. 自己写for循环俩处理
    class Books(View):
      # 获取所有图书
        def get(self, request):
            print(type(request))
            response = {'status': 100, 'data': None}
            books = models.Book.objects.all()
            # 先构造出所有书籍的字典的列表(序列化)
            ll = [{'name': book.name, 'price': book.price} for book in books]
            # 返回数据是json格式数据
            response['data'] = ll
            return JsonResponse(response, safe=False

2. Django内部提供的序列化组件(不可控制，会将所有的数据包括类名一起去发送给前端)
                                
      from django.core import serializers
      class Books(APIView):                       
		 def get(self,request):
                response = {'status': 100, 'data': None}
                books = models.Book.objects.all()
                # 先构造出所有书籍的字典的列表
                # 用django提供的序列化组件
                ret=serializers.serialize('json',books)
            
                # 返回数据是json格式数据
                response['data'] = ret

                return HttpResponse(ret)
        
 3.drf给咱提供的序列化组件（重点） 
                                
    --  # 注： 在setting中要注册一下 rest_farmework
        
        #1.导入drf的序列化类
        from rest_framework.serializers import Serializer
        from rest_framework import serializers
                                                     
        # 2.写一个类继承它(类名随便命名)
        class BookSerializer(Serializer):
            # 可以控制显示哪些字段的数据
            name=serializers.CharField()
            # price=serializers.CharField()
            # date=serializers.CharField()
                                
         #3.类的实例化
         
        def get(self,request):
            books = models.Book.objects.all()
            # 第三步,实例化产生对象
            # instance=books要序列化的queryset对象,many=True,表示序列化多条
            ser=BookSerializer(instance=books,many=True)
            # instance:可以不写,按位置传
            # ser=BookSerializer(books,many=True)
       
            # book = models.Book.objects.all().first()
            # ser=BookSerializer(book,many=False)
            # ser.data 拿到的是序列化之后的字典,字典里可能套了列表,所以safe=False
            import json
            # return HttpResponse(json.dumps(ser.data))

            return JsonResponse(ser.data,safe=False)
```

## 二、drf_实例化组件具体操作

```python
// 对应着表，写序列化的类

// 方式一：

#步骤一:导入模块
from rest_framework import serialzers，Modelserialzers
    
#步骤二：写一个类，继承serialzers
class BookSerializers(serializers.Serializer):
    // 数据库中的字段名 == 对象(后面的内容是一个对象)
     name = serializers.CharField()
        
     # 1.  source可以重命名 得到的是age的字段,指定的字段名和前面的不能重复，即'age'和xxx 不能一样
      xxx =  serializers.CharField(source='age')
        
      # 2. source 得到的publish对象，可以继续点
     publish =serializers.CharField(source='publish.name') 
           
      #3.SerializerMethodField的使用与函数（get_字段名）连用，可以publish显示成一个字典，里面可以带publish对象的各个字段的值
        
     publish =  serializers.SerializerMethodField()
            // 此时的obj就是 book对象
      def get_publish(self,obj):
          dic = {'name':obj.publish.name,'addr':obj.publish.addr}
       	  return dic 
            
      #4. 多对多的显示
    authors=serializers.SerializerMethodField() 
    def get_authors(self,obj):
        // 正向查询字段名.all()
        authors= obj.authors.all()
        
        // 方式一,
        ll = []
        for author in authors :
            ll.apend({'name':author.name,'age':author.age})
            return ll 
        
        '''
        class AuthorSerializers(serializers.Serializer):
                name = serializers.CharField()
                age =  serializers.CharField()       
        '''
        
         // 方式二：AuthorSerializers 是一个类，实现已经写好了
             ret = AuthorSerializers(authors,many=True)
             return ret.data
        
        
//  方式二：

	#步骤一：导入相应的模块
    from app01.models import Books
    from rest_framework import serialzers
    
    #逐步二：写一个类继承ModelSerializer 类
    class Bookserialzers(serialzers.ModelSerializer):
        #1. 再写一个类
        class Meta:
            #2.model = 表名
            model = Books
            
            #3.得到所有的数据
            fileds = "__all__"
            
            #4. 查询指定的数据
            fileds = ['name','price']
            
            #5. 去掉指定的数据,不可以和fileds 一起连用
            exclude =['id']
            
            #6.查询的深度,就是可以跨几个表查询数据
            depth= 2 
     
                
    // 注：source里面可以字段，也可以是对象，还可以还是方法，具体的使用可以看上面。
    // callable的使用
   '''
   //判断func如果是函数，就去执行他，并且把执行结果返回，如果不是函数直接返回
   def text（fun）：
      // 判断func是否可以调用，如果可以调用， 就是True.
       if callable(func):
           ret = func()
        else:
            ret= func
        return ret 
       
   '''
          
```



## 三、HyperlinkedIdentityField的使用

```python
解释： 使用HyperlinkedIdentityField只是为了在字段的后面字显示一个连接地址，必须是继承了ModelSerializer这个类。
    例如： "pulish": "http://127.0.0.1:8000/publish/1"

使用方法：

 #1.在陆有成上的配置：
    url(r'^publish/(?P<pk>\d+)$', views.publish.as_view(),name = 'publish'),


#2.在序列化类中

class BookSerializers(serializers.ModelSerializer):
    class Meta:
        model= models.Books
        fields = "__all__"
    

      '''
       view_name: 为路由层上路由的name值-- publish
       lookup_field：为Book表中的某个字段的名字，--publish_id
       lookup_url_kwarg:为路由层上路由的有名分组的名字 --pk 
       '''
   
    pulish = serializers.HyperlinkedIdentityField(view_name='publish',lookup_field='pulish_id',lookup_url_kwarg='pk')
    
    
    #3.在视图函数上的使用(就是在原有的基础上添加一个context={'request': request})，request代表的        是请求的对象
    
     ret = myserializer.BookSerializers(book, many=False, context={'request': request})
```

## 四、序列化组件的钩子函数

```python
    '''
   数据化校验 --> 类比forms组件：
   name= serializers.CharField(max_length=8,error_messages={"max_length":'长度不超过8'})
   可以再后端的实例化中额ret.errors 中得到错误信息。
   '''
    
    
    '''
   局部钩子:
            1. 函数的名字规则：validate_字段的名字，
            2. value：为字段的名字的值
            3. 校验成功的话：return value，
            4. 不成功的话 ValidationError的异常。
   '''
    
    def validate_name(self, value):
        if value.startswith('sb'):
            # 不能以sb开头
            raise ValidationError('不能以sb开头')
        else:
            return value
        
        
   '''
      全局钩子:
            1. 函数的名字规则：validate，
            2. value：为所有字段的值，
            3. 校验成功的话：return value，
            4. 不成功的话 ValidationError的异常。    
    
   '''
   
    def validate(self, value):
        # value是所有校验通过数据的字典
        print(value)
        name = value.get('name')
        price = value.get('price')
        if name and price:
            if str(name) == str(price):
                return value
            else:
                raise ValidationError('名字跟价格不相等')
        return value

```

## 五、序列化组件的保存

```python
   #注意：要实现数据的保存和修改，其序列化的对象最好是继承了ModelSerializer，不然的话就，就不可以用         save()方法。除非自己在类中重写save()方法。
    
    // 数据的保存
    def post(self, request):
        
        # 1. 对数据前端传过来的数据进行校验：data=request.data
        ret = myserializer.BookSerializers(data=request.data)
        
        # 2. 如果数据校验成功的话
        if ret.is_valid():
            # 直接保存
            ret.save()
            return JsonResponse({'static': 101, 'msg': '保存成功'})

        else:
            return JsonResponse({'static': 101, 'msg': ret.errors})
```

## 六、序列化组件的修改

```python
   // 数据的修改
    def put(self, request, id):
        book = models.Books.objects.filter(id=id).first()
        if book:
            # 注意：在实现数据的校验的过程找那个要加上instance=book。确定修改的对象
            # 与保存的差别就在于：instanc，其他的都一样
            ret = myserializer.BookSerializers(data=request.data, instance=book)
            if ret.is_valid():
                ret.save()
                return JsonResponse({'static': 100, 'msg': '修改成功'})
            else:
                return JsonResponse({'static': 101, 'msg': ret.errors})
        else:
            return JsonResponse({'static': 101, 'msg': '没有此书的信息'})
```

## 七、补充

```python
// 数据的模型
// 使用了choices 的方法。

class User(models.Model):
    id =  models.AutoField(primary_key=True)
    name   = models.CharField(max_length=32)
    pwd   = models.CharField(max_length=32)
    user_choice = ((0, '普通用户'), (1, '会员'), (2, '超级用户'))
    # 指定choice,可以快速的通过数字,取出文字
    user_type = models.IntegerField(choices=user_choice, default=0)
    token = models.OneToOneField(to="Userdetail",to_field='id')
    
    
  // 在使用序列化组件的时候，如何将其user_type的值显示为中文 
  //  注： 在后端可以利用 get_字段名_display() 拿到其中文的名字
    
class User(serializers.ModelSerializer):
    class Meta:
        model = models.User
        fields = '__all__'

    # 显示其用户类型的中文提示：方式一
    user_type= serializers.CharField(source='get_user_type_display')


    # 显示其用户类型的中文提示：方式二
    # user_type=serializers.SerializerMethodField()
    # def get_user_type(self,obj):
    #     return obj.get_user_type_display()
    
    
    
```

