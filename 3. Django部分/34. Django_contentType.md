# Django_contentType

## 一、模型中的设计

```python
// 作用：帮助我们快速链表，可以跟多个表做关联

from django.db import models


from django.contrib.contenttypes.models import  ContentType
from django.contrib.contenttypes.fields import GenericForeignKey,GenericRelation


'''
数据库的分析：
  1.专题课表: id name  --> Course: django入门 Python开发21天入门
  2.学位课程表：id name  -->DegreeCourse: python全栈开发 linux架构
  3.轻课表: id name  -->  lightCourse: 
  4.价格表:id 价格的周期 价格 不同的表id 课程的id  --> PricePolicy  
要实现不同课程的不同周期的课程的价格的查询
'''


#专题课：
class  Course(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32)
    #不需要做数据库的迁移，这个字段不会再数据库中生产，中用来查询
    #第一个参数是对应的哪个表，
    # 第二个参数object_id_field：是课程，
    #第三个参数content_type_field：是表
    policy = GenericRelation(to='PricePolicy',object_id_field='course_id',
                                            content_type_field='table')

  

#学位课：
class  DegreeCourse(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32)
    
    
    # 不需要做数据库的迁移，这个字段不会再数据库中生产，中用来查询,可以通过policy这个字段，快速的得到                          课程的所有的价格策略
    policy = GenericRelation(to='PricePolicy', object_id_field='course_id',                                                           content_type_field='table')

   

#轻客表：
class  LightCourse(models.Model):
    id = models.AutoField(primary_key=True)
    title = models.CharField(max_length=32)
    # 不需要做数据库的迁移，这个字段不会再数据库中生产，中用来查询
    policy = GenericRelation(to='PricePolicy', object_id_field='course_id',                                                            content_type_field='table')


#价格策略表：
class PricePolicy(models.Model):
    id = models.AutoField(primary_key=True)
    # 价格
    price = models.DecimalField(max_digits=8,decimal_places=2)
    
    #周期
    period = models.CharField(max_length=32)
    
    #表的 ，与contentType表相关联 Django自带的表——>可以得到APP下面表的id号
    // 重点
    table = models.ForeignKey(to=ContentType)
    
    # 某个表里面的课程id
    course_id = models.IntegerField()

    #如果表id字段名叫：content_type,课程id字段名叫：object_id  GenericForeignKey就不需要传参数
    #不需要作数据库的迁移，也不会再数据库中生成字段，自用用来做数据的插入
    #如果保存的时候，只需要传 content_obj这个字段，内部会自动的保存 table 和course_id
    content_obj = GenericForeignKey('table','course_id')
    
    // 可以通过这个字段，可以快速的查询出此价格策略的课程，存的时候可以通过这个字段，直接放一个字段
```

## 二、视图函数中的使用

### 1. 数据的创建：GenericForeignKey

```python
def text(request):
    if request.method == 'GET':
               
        '''
        为Django专题课，添加三和个价格策略
        
        最传统的方式
       
        1. 得到课程的对象
        course = models.Course.objects.filter(title='django入门').first()

        2. 得到表的
        table=ContentType.objects.filter(model='course').first()

        3. 进行插入
        ret = models.PricePolicy.objects.create(price=9.9,period='一个月',table=table,course_id=course.pk)
        ret = models.PricePolicy.objects.create(price=19.9,period='三个月',table=table,course_id =course.pk)
        ret = models.PricePolicy.objects.create(price=39.9,period='六个月',table=table,course_id=course.pk)

        '''
        
 // 数据的创建  --> GenericForeignKey
        
        #1. 得到课程的数据
        degree_course= models.DegreeCourse.objects.filter(title='python全栈开发').first()
        
        #2.进行数据的创建 content_obj= degree_course 与 模型中的 GenericForeignKey 相对应
        # 可以实现只要得到某个字段的对象，他就会知道是这个字段对象是哪一个一个表中的字段。实现数据的创           建
        
        models.PricePolicy.objects.create(price=20000,period='5.5个月',content_obj=                                                                           degree_course)
        
        return  HttpResponse('ok')


    
```

### 2.数据的查询：GenericRelation

```python
 '''
  笨方法：django课程表查出 --> course找出模型的名字 --> 去contenttype表中,根据表的名字查询         表的id --> 再去PricePolice表查询所有的价格策略
 '''
 
   def text(request):
        if request.method == 'GET':
           查询：查询Django中所有的价格策略  
            # policy是表cCourse中的一个字段
            course = models.Course.objects.get(pk=1)
            // 查询出所有的图书的数据
            course_policy = course.policy.all()
            for i in course_policy:
                # 得到的是一个
                print(i)
                print(i.period)
            return  HttpResponse('ok')
```

