## Django_forms

## 一. forms 的简介

```
 -- 什么是forms：就是一个类,可以校验字段(前台传过来的字段)
```

## 二、校验字段功能

```python
-先写一个类,继承Form
from django import  forms
from django.forms import widgets
from django.core.exceptions import ValidationError

class Myforms(forms.Form):
    name = forms.CharField(max_length=8, min_length=3,lable ='名字')                                           
    pwd = forms.CharField(max_length=8, min_length=3,lable='密码')
    
    email = forms.EmailField(lable ='邮箱')

  
 def index(request):
    dict = {'name':'jxl','pwd':'jxl123','email':'1@qq.com'}
 	myforms = Myforms(dict)  // 将数据放在Myforms()里面就可以进行数据的检验
    if is_vaild():            // is_valid如果是true表示检验成功，反之，检验失败
        print(myforms.cleaned.data) // myforms.cleaned.data为过滤成功的数据
        return HttpRespones('检验成功')
    else：
    	print(myforms.errors)   //错误的信息 是一个字典
        print(myform.errors.as_data()
        return HttpRespones('检验失败')
              
              
        ----注： 只有执行了 is_vaild() 才会进行数据的校验
```

## 三、渲染模板

```python
 -- 在视图函数层
   def index(request):
    	if request.method =="GET":
           myform = Myform()
       		return render(request,'index.html',local())


-- 方法一：myform

<form action="" method="post" >
    <p>用户名: {{ myform.name }}</p>    //会自动的创建出一个input框 id 为：id_name
    <p>密码:  {{ myform.pwd }}</p>      //id为id_pwd 
    <p>邮箱:  {{ myform.email }}</p>    // id为id_email
    <input type="submit" value="提交">
</form>
<hr>
----myform.name: 拿到的是name的对象，还可以继续‘.’



    
    
--- 第二种方式(for循环form对象,建议用这种)

<form action="" method="post" >
    {% for foo in myform %}
        <p>{{ foo.label }}:{{ foo }}</p>  //foo.label:可以得到之前设置的lable的值
    {% endfor %}

    <input type="submit" value="提交">
</form>



 --- 第三种方式(不建议用)
<form action="" method="post" >

    {{ myform.as_p }}
    {{myforms.as_table}}
    {{ myform.as_ul }}
    <input type="submit" value="提交">
</form>

```

## 四、错误信息的渲染

```python
class Myform(forms.Form):
   name = forms.CharField(max_length=10, min_length=2, label='用户名',
   error_messages={'required': '该字段不能为空', 'invalid': '格式错误', 'max_length': '太                      长','min_length': '太短'},
                           
                          
   注： 一般在 error_messages中重新写错误后的提示信息,要先得到前台传过来的数据，才可以进行校验，然后         再见校验后的提示信息，发给前台
                          
 --- 后端的代码
 def index(request):
      if request.method == 'POST':
              myform = Myform(request.POST)  // 进行数据的校验
              return render(request,'index.html',local())

                         
 -- 前端的代码：
  <div class="row ">
    <div class="col-md-3  col-md-offset-3">
           <form action="" method="post" novalidate >
            {% for foo in myform %}
                <p>{{ foo.label }}:{{ foo }} <span>{{ foo.errors.0 }}</span></p>
            {% endfor %}
      <input type="submit" value="注册" class="btn btn-primary"><span>{{ all_error }}</span>
           </form>
    </div>
</div>    
                          
                          
                          
    -- from对象的错误信息：errors --> 字段名[0] {'字段名'：[错误信息1，错误信息2........]}
                          
    -- 字段的错误信息
 
```

## 五、钩子函数

### 1.局部钩子

```
-定义一个函数,名字叫:clean_字段名字,内部,取出该字段,进行校验,如果通过,将该字段返回,如果失败,抛异常(ValidationError)

	  def clean_name(self):
			# self:当前form对象
			name = self.cleaned_data.get('name')
			
			if name.startswith('sb'):
			# 失败,抛异常
				raise ValidationError('不能以傻逼开头')
				
			# 正常,把name返回
			return name
			
注： 局部钩子抛出的异常错误信息和普通的错误信息一起，可以传到前台，能走到它，说明上面的校验已经成功了
    能把该字段取出来
```

### 2.全局钩子

```
-全局钩子
			#重写clean方法
			def clean(self):
				#程序能走到该函数,前面校验已经通过了,所以可以从cleaned_data中取出密码和确认密码		
				pwd=self.cleaned_data.get('pwd')
				re_pwd=self.cleaned_data.get('re_pwd')
				#进行自己的校验
				if pwd==re_pwd:
					#通过,直接返回cleaned_data
					return self.cleaned_data
				else:
					#失败,抛异常(ValidationError)
					raise ValidationError('两次密码不一致')
	
    
    
    
全局钩子抛出的异常在 :all_error = myform.errors.get('__all__')[0]

  all_error = myform.errors.get('__all__')
            if all_error:
                all_error = all_error[0] // 传数据时 为了避免不报错可以这样写 
                
     注：能走到这里，说明已经上面的全部都已经校验过来了人，包括局部钩子
     --：在做密码校验的时候，可能取到的密码为空
                
```

## 六、基于forms实现注册功能

```python
1. -- 创建数据表
  class User(models.Model):
        id = models.AutoField(primary_key=True)
        name = models.CharField(max_length=8)
        pwd  = models.CharField(max_length=8)
        email = models.EmailField()


2. -- 创建 Myforms类
rom django import  forms
from django.forms import widgets
from django.core.exceptions import ValidationError
from app01.models  import  *
import  json


class Myforms(forms.Form):
    name = forms.CharField(max_length=8, min_length=3, label='用户名',
                           error_messages={'max_length': '最长是8', 'min_length': '最短是3', 'required': '这个必须填'},
                           widget=widgets.TextInput(attrs={'class': 'form-control'}))
    pwd = forms.CharField(max_length=8, min_length=3, required=True, label='密码',
                          error_messages={'max_length': '最长是8', 'min_length': '最短是3', 'required': '这个必须填'},
                          widget=widgets.PasswordInput(attrs={'class': 'form-control'}))
    re_pwd = forms.CharField(max_length=8, min_length=3, required=True, label='确认密码',
                             error_messages={'max_length': '最长是8', 'min_length': '最短是3', 'required': '这个必须填'},
                             widget=widgets.PasswordInput(attrs={'class': 'form-control'}))
    # 校验是否是邮箱格式
    email = forms.EmailField(label='邮箱', error_messages={'required': '这个必须填', 'invalid': '不符合邮箱格式'},
                            widget=widgets.EmailInput(attrs={'class': 'form-control'}) )

    #局部钩子
    def clean_name(self):
        # self:当前form对象
        name = self.cleaned_data.get('name')
        li = []
        user_list = User.objects.all()
        for user in user_list:
            li.append(user.name)

        if name.startswith('sb'):
            # 失败,抛异常
            raise ValidationError('不能以sb开头')
        elif name in li:
            raise ValidationError('此账号已经存在')
        # 正常,把name返回
        return name


    #全局过滤器
    def clean(self):
        pwd=self.cleaned_data.get('pwd')
        re_pwd=self.cleaned_data.get('re_pwd')
        if pwd==re_pwd:
            return self.cleaned_data
        else:
            raise ValidationError('两次密码不一致')
            
            
3. -- 后端代码：
	def register(request):
        if request.method == 'GET':
            myform = Myforms()

        elif  request.method == 'POST':
            # 按照普通的form表单接收数据
            myform = Myforms(request.POST)

            if myform.is_valid():
                myform.cleaned_data.pop('re_pwd')
                User.objects.create(**myform.cleaned_data)
                return  HttpResponse('注册成功')

            else:
                all_error = myform.errors.get('__all__')
                if all_error:
                    all_error = all_error[0]


       	 return render(request, 'register.html', locals())
    
    
    
    4.---前端的代码：
       <div class="row ">
    <div class="col-md-3  col-md-offset-3">
           <form action="" method="post" novalidate >
            {% for foo in myform %}
                <p>{{ foo.label }}:{{ foo }} <span>{{ foo.errors.0 }}</span></p>
            {% endfor %}

               <input type="submit" value="注册" class="btn btn-primary"><span>{{                          all_error }}</span>
           </form>
    </div>
</div>
```

## 七、基于json实现注册功能

```
-- 后端的代码
def register(request):
    if request.method == 'GET':
        myform = Myforms()

    elif request.method == 'POST':
        # 按照json的方式接收数据
        myform = Myforms(json.loads(request.body.decode('utf-8')))

        if myform.is_valid():
            myform.cleaned_data.pop('re_pwd')
            User.objects.create(**myform.cleaned_data)
            return HttpResponse(1)

        else:
            dic={'errors':myform.errors,'all_error':None}

            all_error = myform.errors.get('__all__')
            if all_error:
                all_error = all_error[0]
                dic["all_error"] = all_error

            return  JsonResponse(dic)

    return render(request, 'register.html', locals())
    
    
    
   --- 前端代码：
      <div class="row ">
    <div class="col-md-3  col-md-offset-3">
        <form action="" novalidate>
            {% for foo in myform %}
                <p>{{ foo.label }}:{{ foo }} <span class='sp1'></span></p>
            {% endfor %}

        </form>
        <button class="btn">注册</button>
        <span class='sp2'></span>
        </div>
    </div>
    <script>

    // 当用户框失去焦点的时候，就向后端发送数据，判断用户是否已经被注册
    $('#id_name').blur(function () {
       var  data= {'name':$("#id_name").val(),};

       data = JSON.stringify(data);
       $.ajax({
           contentType: 'application/json',
           dataType: 'json',
           url: '/register/',
           type: "post",
           data: data,
           success: function (data) {
              $('#id_name').next('span').text(data.errors.name)
           }

       })
    });

	// 将数据全部发送给后端，进行判断
    $(".btn").click(function () {
        var data_dic = {
            'name': $('#id_name').val(),
            'pwd': $('#id_pwd').val(),
            're_pwd': $('#id_re_pwd').val(),
            'email': $('#id_email').val(),
        };
        info = JSON.stringify(data_dic);
        $.ajax({
            url: '/register/',
            type: 'post',
            data: info,
            contentType: 'application/json',
            dataType: 'json',
            success: function (data) {
                if (data == 1) {
                    alert('注册成功')
                }
                else {
                    $(".sp2").text(data.all_error);
                    $.each(data.errors,function (key,value) {
                        str = "#id_" + key;
                        $(str).next('span').text(value[0])

                    })

                }

            }
        })
    });

</script>


注：事先先导入jQuery和bootstrap 来对页面进行简单的布局和修饰

```

