# Rest Formwork_分页器

## 一、 普通分页

```python
# 导入响应的模块

from rest_framework.pagination import PageNumberPagination,

'''
 普通的分页器:PageNumberPagination
 
 参数：  
 page_size：每页显示的条数 -->  page_size = 3 默认每页显示3条数据
 page_query_param = 'aa': 查询的key,问号的后面 指定显示的第几页 -->  ?aa=1 查询第一页的数据
 page_size_query_param= 'size':指定当前页显示的条数 -->  ？size= 5  当前显示的条数为5 
 max_page_size：每页显示最多的条数，制约page_size_query_param  -->  
'''

class Book(ViewSetMixin, APIView):
    def get_all(self, request):
        book_list = models.Boook.objects.all()
        # 实例化一个对象
        page = PageNumberPagination()
        #可以得到基类的属性，可以修改，也可以在settings中配置
        
        # 默认显示的页数
        page.page_size = 2
        
        #当前页显示的最大条数
        page.max_page_size = 5
        
        #得到指定页数的数据 在浏览器上加？拼接 ？page=3 --> 得到第三页的数据
        page.page_query_param = 'page'
        
        # 可以根据size这个key，来可以设置当前页的显示的数据的条数 --? ?size=5
        page.page_size_query_param = 'size'

        # 得到分页的数据
        page_list = page.paginate_queryset(book_list,request,self)
       
        ret = myser.Bookserializers(instance=page_list, many=True)
        response = {'status': 100, 'msg': '查询成功'}
        response['data'] = ret.data
        # return Response(response)
        #  返回的也是一个页面 ，有上一页和下一页的连接
        return  page.get_paginated_response(ret.data)

    // 注： 自己也可以写一个类继承PageNumberPagination 类，然后重写里面的属性。

```

## 二、偏移分页器

```Python
#导入模块
from rest_framework.pagination import LimitOffsetPagination

'''
偏移分页器:LimitOffsetPagination：
    参数：        
default_limit ： 默认显示的数据条数
limit_query_param = 'limit' ：设置当前页显示的条数
max_limit = None ：最大的显示条数
offset_query_param = 'offset' 在浏览器上写 ? offset = 4 就是在将数据偏移4个 数据的第一个就是5

'''

class Book(ViewSetMixin, APIView):
    def get_all(self, request):
        book_list = models.Boook.objects.all()
        
        # 实例化一个对象
        page = LimitOffsetPagination()
      
        # 默认显示的页数
        page.default_limit = 2
        
        #当前页显示的最大条数
        page.max_limit = 5
        
        #在浏览器上写 ? offset = 4 就是在将数据偏移4个 数据的第一个就是5
        page.offset_query_param = 'offset'
        
        # 可以根据size这个key，来可以设置当前页的显示的数据的条数 --? ?size=5
        page.limit_query_param = 'size'

        # 得到分页的数据
        page_list = page.paginate_queryset(book_list,request,self)

        ret = myser.Bookserializers(instance=page_list, many=True)
        response = {'status': 100, 'msg': '查询成功'}
        response['data'] = ret.data
        
        #  返回的也是一个页面 ，有上一页和下一页的连接
        return  page.get_paginated_response(ret.data)

```

## 三、加密分页器

```python
# 先导入相应的模块
from rest_framework.pagination import CursorPagination

'''
加密分页器 (速度是最快的):CursorPagination

参数：
cursor_query_param = 'cursor'：在浏览器上面的指定的页数 但是已经加密了，有上一页和下一页数据的连接
page_size： 默认的显示的数据条数
ordering = 'nid'  以哪个字段进行排序，
page_size_query_param = 'size' 可以指定当前页显示的数据条数
max_page_size：最大的显示的数据
'''

class Book(ViewSetMixin, APIView):
    def get_all(self, request):
        book_list = models.Boook.objects.all()
        
        # 实例化一个对象
        page = CursorPagination()
   
        # 默认显示的页数
        page.page_size = 2
        
        #当前页显示的最大条数
        page.max_page_size = 5
        
        #根据哪个字段进行排序
        page.ordering = 'nid'
        
        # 可以根据size这个key，来可以设置当前页的显示的数据的条数 --? ?size=5
        page.page_size_query_param = 'size'

        # 得到分页的数据
        page_list = page.paginate_queryset(book_list,request,self)

        ret = myser.Bookserializers(instance=page_list, many=True)
        response = {'status': 100, 'msg': '查询成功'}
        response['data'] = ret.data
        # return Response(response)
        #  返回的也是一个页面 ，有上一页和下一页的连接
        return  page.get_paginated_response(ret.data)

```

