# Rest Formwork_视图

```python
// 技术的要求
 
 #在视图函数中，显现冗余代码的封装
```

## 方式一(自己封装)

```python
 // 所有数据的查询类
    
class List:
    def list(self, request):
        
         # querset 和 querysetserializers:有实例化的对象提供 下同。
        ret = self.querysetserializers(instance=self.querset, many=True)
        
        response = {'status': 100, 'data': ret.data}

        return JsonResponse(response, safe=False)
    

// 数据的新增类

class Create:
    def create(self, request):
        response = {'status': 100, 'msg': '新增成功'}
       
        ret = self.querysetserializers(data=request.data)
        if ret.is_valid():
            ret.save()
        else:
            response['status'] = 101
            response['mag'] = ret.errors

        return JsonResponse(response, safe=False)


// 继承上面所写的查看数据和新增的类

class Books(APIView, List, Create):
    querset = models.Book.objects.all()
    querysetserializers = myser.Bookserializers

    # 展示
    def get(self, request):
        return self.list(request)

    # 图书的新增
    def post(self, request):
        return self.create(request)


class Publish(APIView, List, Create):
    # 出版社的查看
    // querset,querysetserializers给继承的类提供数据
    
    querset = models.Publish.objects.all()
    querysetserializers = myser.Publishserializers

    def get(self, request):
        return self.list(request)

    # 出版社的新增
    def post(self, request):

```

## 方式二（drf封装的类）

```python
// 导入相应的包
from rest_framework.mixins import ListModelMixin, CreateModelMixin, RetrieveModelMixin, UpdateModelMixin,  DestroyModelMixin

// 要先继承GenericAPIView类

from rest_framework.generics import GenericAPIView

'''
ListModelMixin: list --> 展示所有的
CreateModelMixin :create --> 新增数据
UpdateModelMixin: update --> 修改一条数据
RetrieveModelMixin : retrieve --> 查看一条数据
DestroyModelMixin： destroy  -->删除一条数据

'''

# 图书，
class Books(GenericAPIView, ListModelMixin, CreateModelMixin):
    queryset = models.Book.objects.all()
    serializer_class = myser.Bookserializers

    # 展示所有的数据：list
    def get(self, request):
        # 此时的 list是 ListModelMixin内置的函数属性
        return self.list(request)

  # 图书的新增：create
    def post(self, request):
        # 此时的 list是 CreateModelMixin内置的函数属性
        return self.create(request)

class Bookdetail(GenericAPIView,RetrieveModelMixin,DestroyModelMixin,UpdateModelMixin):
    queryset = models.Book.objects.all()
    serializer_class = myser.Bookserializers

   # 展示指定的图书：retrieve
    def get(self, request,pk):
        return self.retrieve(request,pk)

     # 修改数据：update
    def put(self,request,pk):
        return self.update(request,pk)

     #删除数据：destroy
    def delete(self,request,pk):
        return self.destroy(request,pk)


```

## 方式三 (进一步的封装)

```python
// 导入相应的包

from rest_framework.generics import GenericAPIView,ListCreateAPIView,ListAPIView,RetrieveUpdateAPIView,RetrieveUpdateDestroyAPIView
 
'''
ListCreateAPIView: 查看所有和新增
ListAPIView: 查看所有数据
RetrieveUpdateAPIView: 新增一条数据，更新数据
RetrieveUpdateDestroyAPIView: 新增一条数据，更新数据，删除数据
'''

// 将get/post等方法的实现一并封装了。

 class Publish(ListCreateAPIView):
     queryset =models.Publish.objects.all()
     serializer_class = myser.Publishserializers

 class PublishDetail(RetrieveUpdateDestroyAPIView):
     queryset =models.Publish.objects.all()
     serializer_class = myser.Publishserializers
```

## 方式四(不建议使用)

```python
# 需要在路由上在进行配置，就可以实现五种查找方式 可以快速的实现数据的增删改查

// 局限性太强

// 1. 导入相应的包
from rest_framework.viewsets import ModelViewSet

//2. 必须继承ModelViewSet

class Publish(ModelViewSet):
    queryset =models.Publish.objects.all()
    serializer_class = myser.Publishserializers
   


# 在路由层上的配置
    url(r'^publishs/$', views.Publish.as_view({'get': 'list', 'post': 'create'})),
    
    url(r'^publishs/(?P<pk>\d+)/$', views.Publish.as_view({'get': 'retrieve', 'put': 'update','delete':'destroy'})),
    

```

## 方式五：(建议使用):ViewSetMixin

```python
建议使用 ViewSetMixin 魔法类，可以实现写的函数不一定是get 或者 post
 好处：跟某个功能相关的，可以写在一起

'''
from django.conf import  settings
得到的setting就是py文件的settings里面的内容
'''

from rest_framework.viewsets import  ViewSetMixin

# 注意先后顺序：ViewSetMixin写在前面

class Text(ViewSetMixin,APIView):
    def text(self,request):
        return  HttpResponse('text')

    def text2(self,request):
        return  HttpResponse('text2')

    def text3(self, request):
        return HttpResponse('text3')
   

在路由上的配置：
     url(r'^text1/$', views.Text.as_view({'get': 'text'})),
     url(r'^text2/$', views.Text.as_view({'get': 'text2'})),
     url(r'^text3/$', views.Text.as_view({'get': 'text3'})),
```

