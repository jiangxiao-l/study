# Rest Formwork_权限组件

## 一、权限组件的局部使用

```python
#1.定义一个类
  from app01 import models

 class UserPermission():
        // 函数的名字一定是has_permission
        def has_permission(self,request,view):
            
            // 此时的request是已经装饰后的request,此时的request.user 是基于上一次登入等到的信                  息，并不都是这样的。 view 就是当前的试图类
       
            user = request.user
            user_type = user.user_type
            
            //判端用户是否是超级用户 
            if user_type == 2:
				return Ture
            else:
                return False
            
   
    
   #2.在要用到权限组件的类中添加一条数据：permission_classes = [UserPermission，]

    class User(APIView):
        
       # 列表的名字一定是要 permission_classes
        permission_classes = [UserPermission，]
        
        def get(self, request): 
            response = {'status': 100, 'msg': '查询成功'}
            ret = models.User.objects.all()
            user_ser = Myserial.User(ret, many=True)
            response['data'] = user_ser.data
            return JsonResponse(response, safe=False)

```

## 二、权限组件的全局使用

```python

# 在settings.py 文件中设置。 而且此时的权限组件就不可以在视图函数中定义，需要在另一个文件这个重新写。

'''
     app01：是APP的名字   
     MyAuth：是有权限组件的py文件。
     UserPermission：是权限组件的类名。
'''
 #  REST_FRAMEWORK 这个可以放权限的组件，也可以放认证的组件。

 REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': ['app01.MyAuth.UserPermission',]
}
```

## 三、权限组件的局部禁用

```python
# 在要使用权限组件的类中添加一个空的指定的列表

class User(APIView):

    # 权限的局部禁用
    permission_classes = []
    def get(self, request):

        response = {'status': 100, 'msg': '查询成功'}
        ret = models.User.objects.all()
        user_ser = Myserial.User(ret, many=True)
        response['data'] = user_ser.data
        return JsonResponse(response, safe=False)



```

## 四、其他

```python
# 如歌要实现同一个类中的不同请求的不同权限的设置？

// 解决的方案：因为在权限类中的request中可以得到请求单位方式Lrequest.meth。然后在进行判断。例如只有在请求的方式为post才进行权限类的过滤。
    
    
    
    

```

