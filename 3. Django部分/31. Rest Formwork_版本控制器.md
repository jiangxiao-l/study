# Rest Formwork_版本控制器

## 一、QueryParameterVersioning 控制器

```python
# 在get里面取 直接拼在路径的后面 /?version

1.在settings.py 文件里配置

 REST_FRAMEWORK = {   
    # 'DEFAULT_VERSIONING_CLASS':'',
     
    'VERSION_PARAM':'version = v1 ',  --> 可以指定浏览器上的？后面的/?version = v1 
    # 如果没有设置就是v1
    'DEFAULT_VERSION':'v1',
    # 允许的版本
    'ALLOWED_VERSIONS': ['v1', 'v2'],
}
   


class Book(ViewSetMixin, APIView):
    
    #versioning_class 只能写一个
    
    versioning_class = QueryParameterVersioning
    

    def get_all(self, request, *args, **kwargs):
     

        book_list = models.Boook.objects.all()
        # 实例化一个对象
        page = CursorPagination()
        # 可以得到基类的属性，可以修改，也可以在settings中配置
        # 默认显示的页数
        page.page_size = 2
        # 当前页显示的最大条数
        page.max_page_size = 5
        # 根据哪个字段进行排序
        page.ordering = 'nid'
        # 可以根据size这个key，来可以设置当前页的显示的数据的条数 --? ?size=5
        page.page_size_query_param = 'size'
        # 得到分页的数据
        page_list = page.paginate_queryset(book_list, request, self)

        ret = myser.Bookserializers(instance=page_list, many=True)
        response = {'status': 100, 'msg': '查询成功'}
        response['data'] = ret.data
        # return Response(response)
        #  返回的也是一个页面 ，有上一页和下一页的连接
        return page.get_paginated_response(ret.data)
    
```

## 二、**URLPathVersioning控制器**

```python
# 在有名分组里面取  /version=v1/book  要在路由层上进行配置

1.在settings.py 文件里配置

 REST_FRAMEWORK = {   
    # 'DEFAULT_VERSIONING_CLASS':'',
     
    'VERSION_PARAM':'version = v1 ',  --> 可以指定浏览器上的？后面的/?version = v1 
    # 如果没有设置就是v1
    'DEFAULT_VERSION':'v1',
    # 允许的版本
    'ALLOWED_VERSIONS': ['v1', 'v2'],
}

2. 在路由上配值 设置name,方便后面的反向解析使用 version 在setting中配置
 url(r'^(?P<version>[v1|v2|v3]+)/books/$', views.Book.as_view({'get': 'get_all'}),     name='ttt'),
    
   class Book(ViewSetMixin, APIView):
        # 将
        versioning_class = URLPathVersioning

        def get_all(self, request, *args, **kwargs):
            
            # print(request.version)
            # 路由反向解析 
            
           '''
             方式一：原生Django的方向解析
                 from django.urls import reverse
                 url2=reverse(viewname='ttt',kwargs={'version':request.version})
                 print(url2)
             提供给咱的解析 返回一个数据的连接
           '''
            #方式二：
            url2 = request.versioning_scheme.reverse('ttt', request=request)
            print(url2)

            book_list = models.Boook.objects.all()
            # 实例化一个对象
            page = CursorPagination()
            # 可以得到基类的属性，可以修改，也可以在settings中配置
            # 默认显示的页数
            page.page_size = 2
            # 当前页显示的最大条数
            page.max_page_size = 5
            # 根据哪个字段进行排序
            page.ordering = 'nid'
            # 可以根据size这个key，来可以设置当前页的显示的数据的条数 --? ?size=5
            page.page_size_query_param = 'size'
            # 得到分页的数据
            page_list = page.paginate_queryset(book_list, request, self)

            ret = myser.Bookserializers(instance=page_list, many=True)
            response = {'status': 100, 'msg': '查询成功'}
            response['data'] = ret.data
            # return Response(response)
            #  返回的也是一个页面 ，有上一页和下一页的连接
            return page.get_paginated_response(ret.data)

```

