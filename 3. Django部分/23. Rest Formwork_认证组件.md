# Rest Formwork_认证组件

## 一、认证组件局部使用

```python
#1.先定义一个auth的类

from rest_framework import exceptions

class Auth:
    
    // 函数的名字一定是 authenticate
    
    def authenticate(self, request):
        token = request.GET.get('token')
        ret = models.User.objects.filter(token=token).first()
        if ret:
            // 已经是登入了。 后端将其解压复制给两个数，一旦return了有数据的值，那么在使用此认证组件                的时候，就只会运行列表的第一个。因为在源码中直接就return了。 
               一个给了request.user ,一个给了request.auth。可与在后面取到传给的值。
              
            return ret.user,ret 
        else:
            // 抛出一个异常
            raise exceptions.APIException('请先登入')
            
#2.在需要加上认证的类中加上：authentication_classes = [Auth, ]

class Books(APIView):
    # 局部使用
    authentication_classes = [Auth, ]
    def get(self, request):
        response = {'static': 12312, "data": None}
        books = models.Books.objects.all()
        ret = myserializer.BookSerializers(instance=books, many=True, context={'request': request})
        response['data'] = ret.data
        return JsonResponse(response, safe=False)
    
   
```

## 二、认证组件的全局使用

```python
# 在setting.py 文件中进行设置

// 注意：此时认证的类，即就是：Auth 已经不能写下view.py 文件中。需要写在另一个py文件中。

// auth类的写法与上面的写法一致。

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': ['app01.MyAuth.Auth',],    
}
```

## 三、认证组件的局部禁用

```python
# 要使用认证组件的类中，添加一个空的列表 即： authentication_classes = []
```

## 四、不保存token实现登入验证

```python

#生成随机数
def make_token(id,salt='123'):
    md5= hashlib.md5()
    md5.update(str(id).encode('utf-8'))
    md5.update(salt.encode('utf-8'))
    return  md5.hexdigest()+ '|'+ str(id)

 #检验随机数
# 后台闯过来的数据token：2cfd4560539f887a5e420412b370b361|1
def check_token(token,salt='123'):
    if token:
        ll=token.split("|")
        md5 = hashlib.md5()
        md5.update(ll[-1].encode('utf-8'))
        md5.update(salt.encode('utf-8'))
        if ll[0] == md5.hexdigest():
            return  True
        else:
            return False
    else:
        return  False

#认证的类
from rest_framework.exceptions import APIException
class Auth:
    def authenticate(self, request):
        token = request.GET.get('token')
        ret = check_token(token)
        if ret:
            return
        else:
            raise APIException('请先登入')

#使用：
class Login(APIView):
    def post(self, request):
        respose = {'status': 100, 'msg:': '登入成功'}
        name = request.data.get('name')
        pwd = request.data.get('pwd')
        try:
            # 登入成功
            user = models.User.objects.filter(name=name, pwd=pwd).first()
            # 返回随机数token
            token = make_token(user.id)
            respose['token'] = token
        except ObjectDoesNotExist as e:
            respose['status'] = 101
            respose['msg'] = '账号或者密码错误'
        except Exception as e:
            respose['msg'] = str(e)
        return JsonResponse(respose)


    
    
class Book(APIView):
    authentication_classes = [Auth,]
    def get(self, request):
        response = {'status': 100, 'msg': '查询成功'}
        ret = models.Books.objects.all()
        book_ser = Myserial.Bookserializers(ret, many=True)
        response['data'] = book_ser.data
        return JsonResponse(response, safe=False)
```

