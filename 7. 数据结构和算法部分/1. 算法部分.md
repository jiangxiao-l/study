# 算法部分

## 1. 冒泡排序

```python
# 让相邻的数进行对比
# 时间复杂度：O(n^2)
# 空间复杂度：O(1)

def bubble_sort(li):
     for i in ranage(len(li)-1):
            flage = False
            for j in ranage(len(li)-i-1):
                 if li[j] > li[j+1]:
                     li[j],li[j+1] = li[j+1],li[j]
                     flage=Ture
             if not flage:
                return 
                     
```

## 2. 选择排序

```python
# 一遍历出最小的数，放在第一个位子上，再一趟遍历记录剩余列表中的数
# 时间复杂度：O(n^2)
#空间复杂度：O(1)

def select_sort(li):
     for i in ranage(len(li)-1):
            minlog =i
            for j in range(i+1,len(li)):
                 if  li[j]< li[minlog]:
                        li[minlog],li[j] = li[j],li[minlog]
```

## 3. 插入排序

```python 
# 时间复杂度：O(n^2)
# 空间复杂度：O(1)

def insert_sort(li):
    for i in ranage(len(li)):
         temp = li[i]
         j = i -1
        
         while j >= 0 and temp<li[j]:
                li[j+1] = li[j]
                j=j-1
                
         li[j+1] = temp
            
```

## 4.快速排序

```Python
'''
取一个元素p（第一个元素），使元素p归位；
列表被p分成两部分，左边都比p小，右边都比p大；
递归完成排序。
'''
# 时间复杂度：O(nlogn)
# 空间复杂度：O(n)
 

def patition(li, left, right):
    temp = li[left]  # 最左边的数
    
    while left < right:
        
        while left < right and temp <= li[right]:
            right = right - 1
            
        li[left] = li[right]
        
        while left < right and temp >= li[left]:
            
            left = left + 1
            
        li[right] = li[left]

    li[left] = temp
    return left


def quick_sort(li, left, right):
    if left < right:
        mid = patition(li, left, right)
        quick_sort(li, left, mid - 1)
        quick_sort(li, mid + 1, right)
```

## 5. 归并排序

```python
'''
分解：将列表越分越小，直至分成一个元素。
一个元素是有序的。
合并：将两个有序列表归并，列表越来越大

'''
# 时间复杂度：O(logn)
# 空间复杂度：O(n)

def merge(li,left,mid,right):
    i = left
    j = mid + 1
    temp_list = []
    while i <= mid and  j <= right:
        if li[i] < li[j]:
             temp_list.append(li[i])
             i = i + 1
        else:
            temp_list.append(li[j])
            j = j+1

    while i<= mid:
         temp_list.append(li[i])
         i = i+1

    while j <= right:
         temp_list.append(li[j])
         j= j+1

    # 将排序后的Li赋值給原来的列表
    li[left:right+1] = temp_list


def merge_sort(li,left,right):
    if left <  right:
         # 中间的索引
         mid = (left + right) //2
         merge_sort(li,left,mid)
         merge_sort(li,mid+1,right)
         merge(li,left,mid, right)
```

## 6. 希尔排序

```Python
'''
希尔排序是一种分组插入排序算法。
首先取一个整数d1=n/2，将元素分为d1个组，每组相邻量元素之间距离为d1，在各组内进行直接插入排序；
取第二个整数d2=d1/2，重复上述分组排序过程，直到di=1，即所有元素在同一组内进行直接插入排序。

希尔排序每趟并不使某些元素有序，而是使整体数据越来越接近有序；最后一趟排序使得所有数据有序

时间复杂度：0((0+T)n)
空间复杂度：o(1.3n)
'''

def shell_sort(li):
    gap = len(li) // 2   
    while gap > 0:
        for i in range(gap, len(li)):
            tmp = li[i]
            j = i - gap
            while j >= 0 and tmp < li[j]:
                li[j + gap] = li[j]
                j -= gap
            li[j + gap] = tmp
            
         gap //= 2

```



## 7. 计数排序

```python

# 创建一个列表，用来统计每个数出现的次数

def count_sort(li):
    ltemp  = [0 for i in range(11)]
    for x in li:
        ltemp[x] += 1

    li.clear()
    for index,value in enumerate(ltemp):
        for v in range(value):
            li.append(index)

    return  li
res = count_sort([8, 3, 0, 1, 10, 4, 7,0,2,3])
print(res)

```

## 8. 总结

```python
# 1. 一般情况下，就运行时间而言：快速排序 < 归并排序 < 堆排序


2.
'''
时间复杂度是用来估计算法运行时间的一个式子（单位）。
一般来说，时间复杂度高的算法比复杂度低的算法慢。
常见的时间复杂度（按效率排序）
O(1)<O(logn)<O(n)<O(nlogn)<O(n2)<O(n2logn)<O(n3)
不常见的时间复杂度（看看就好）
O(n!) O(2n) O(nn) …

如何一眼判断时间复杂度？
循环减半的过程O(logn)
几次循环就是n的几次方的复杂度
'''
 
```

