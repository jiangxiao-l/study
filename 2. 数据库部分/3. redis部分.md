# redis部分

## 1.介绍

```2. 
nosql:非关系型数据库
 
以key:values的形式存储数据    
```

## 2. 功能特性

```
高速读写
数据类型丰富 （笔试，面试）***
支持持久化    （笔试 面试）***
多种内存分配及回收机策略
支持事物    （面试）***
消息队列，消息订阅
支持高可用     ****
支持分布式集群   ****
缓存穿透，雪崩    ****
redis Api    ****
```

## 3. 企业缓存产品的具体介绍

```    Python
# mencached: 
 	优点：高性能读写，第一数据类型，支持客户端的分布式集群，一致性hash,多核结构，多线程读写性能高。
 	缺点：无持久化，节点故障可能出现缓存击穿，分布式需要客户端实现，跨机房数据同步困难，结构扩张复杂度高。
 	
# redis:
    优点：高性能读写，支持多数据类型，数据持久化，高可用架构，支持自定义虚拟内存，支持分布式集群，单线程读写性能极高。
    缺点：对线程读写较memcached慢
    新浪，京东，直播类平台 网页游戏
   
#Memcached 适合，多用户访问，每个用户少量的rw 

# redis  适合，少用户访问，每个用户大量的rw

# Tair：
    优点：高性能读写，支持三种存储引擎(ddb,rdb,ldb)支持高可用，支持分布式分片集群、支撑了几乎所有淘宝业务的缓存。
     缺点：单机情况下，读写性能较其他两种产品较慢  

```

## 4. redis的安装部署

```

下载：
wget http://download.redis.io/releases/redis-3.2.12.tar.gz
解压：

上传至 /data
tar xzf redis-3.2.12.tar.gz
mv redis-3.2.12 redis
安装：
cd redis
make
启动：
src/redis-server &

环境变量的配置：
vim /etc/profile 
export PATH=/data/redis/src:$PATH
source /etc/profile 


```

## 5.redis基本管理操作

### 5.1 redis 的基本配置

```
[root@standby ~]# redis-cli  shutdown 

mkdir /data/6379

cat >>/data/6379/redis.conf <<EOF
daemonize yes
port 6379
logfile /data/6379/redis.log
dir /data/6379
dbfilename dump.rdb
EOF


重启redis：
redis-cli shutdown 
redis-server /data/6379/redis.conf 
netstat -lnp|grep 63


+++++++++++配置文件说明++++++++++++++
redis.conf
是否后台运行：
daemonize yes
默认端口：
port 6379
日志文件位置
logfile /var/log/redis.log
持久化文件存储位置
dir /data/6379
RDB持久化数据文件:
dbfilename dump.rdb
+++++++++++++++++++++++++


redis-cli 客户端命令常用参数说明

redis-cli 刚装完,可以在redis服务器上直接登录redis
-p 6379   指定端口号
-h        指定链接地址
-a        指定链接密码
redis-cli  set num  10 ,无交互执行redis命令
cat /tmp/1.txt |redis-cli

[root@db01 ~]# redis-cli -h 10.0.0.51  -p 6379
10.0.0.51:6379> 
```

### 5.2 redis的安全配置

```
redis默认开启了保护模式，只允许本地回环地址登录并访问数据库。

禁止protected-mode

protected-mode yes/no （保护模式，是否只允许本地访问）
----------------------

(1)Bind :指定IP进行监听
echo "bind 10.0.0.200  127.0.0.1" >>/data/6379/redis.conf
(2)增加requirepass  {password}
echo "requirepass 123" >>/data/6379/redis.conf

重启redis
redis-cli shutdown 
redis-server /data/6379/redis.conf 

----------验证-----
方法一：
[root@db03 ~]# redis-cli -a 123
127.0.0.1:6379> set name zhangsan 
OK
127.0.0.1:6379> exit
方法二：
[root@db03 ~]# redis-cli
127.0.0.1:6379> auth 123
OK
127.0.0.1:6379> set a b

```

### 5.4 redis数据的持久化

```
作用： 可以有效防止,在redis宕机后,缓存失效的问题.

RDB 持久化：
	可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。
    优点：速度快，适合于用做备份，主从复制也是基于RDB持久化功能实现的。
    缺点：会有数据丢失
    
 
RDB持久化核心配置参数：

vim /data/6379/redis.conf
dir /data/6379
dbfilename dump.rdb

save 900 1
save 300 10
save 60 10000

配置分别表示：
900秒（15分钟）内有1个更改
300秒（5分钟）内有10个更改
60秒内有10000个更改



AOF 持久化(append-only log file)
	记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 
    AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。
    优点：可以最大程度保证数据不丢
    缺点：日志记录量级比较大
    
AOF持久化配置的参数：
appendonly yes
appendfsync everysec：每分钟
appendfsync always：总是
appendfsync no：不

是否打开aof日志功能
每1个命令,都立即同步到aof 
每秒写1次
写入工作交给操作系统,由操作系统判断缓冲区大小,统一写入到aof.

配置文件的配置：
vim /data/6379/redis.conf
appendonly yes
appendfsync everysec 

面试： 
redis 持久化方式有哪些？有什么区别？
rdb：基于快照的持久化，速度更快，一般用作备份，主从复制也是依赖于rdb持久化功能
aof：以追加的方式记录redis操作日志的文件。可以最大程度的保证redis数据安全，类似于mysql的binlog

```

## 6.redis的数据类型

### 6.1 介绍

```
String ：     字符类型
Hash：        字典类型
List：        列表     
Set：         集合 
Sorted set：  有序集合
```

### 6.2 键的通用操作

```
KEYS * 	 keys a  keys a*	查看已存在所有键的名字   ****
TYPE						返回键所存储值的类型     ****
EXISTS 				        检查是否存在             *****
EXPIRE\ PEXPIRE 			以秒\毫秒设定生存时间       ***
TTL\ PTTL 					以秒\毫秒为单位返回生存时间 ***
PERSIST 					取消生存实现设置            ***
DEL							删除一个key
RENAME 				        变更KEY名

---例子：
127.0.0.1:6379> set name zhangsan 
127.0.0.1:6379> EXPIRE name 60
(integer) 1
127.0.0.1:6379> ttl name
(integer) 57
127.0.0.1:6379> set a b ex 60
OK
127.0.0.1:6379> ttl a
127.0.0.1:6379> PERSIST a
(integer) 1
127.0.0.1:6379> ttl a
(integer) -1
```

### 6.3 数据类型具体使用的场所

```
 string：
 
    常规计数：
    微博数，粉丝数等。
    订阅、礼物、页游
    计数器：每点一次关注，都执行以下命令一次
 
 
  hash类型：
  
      存储部分变更的数据，如用户信息等。
      最接近mysql表结构的一种类型

 
 LIST（列表）
 
消息队列系统
比如sina微博:在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。
但是做了限制不能超过5000个ID，因此获取ID的函数会一直询问Redis。
只有在start/count参数超出了这个范围的时候，才需要去访问数据库。
系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。
SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，
而主页或第一个评论页是不会麻烦到硬盘上的数据库了。
    
 SortedSet（有序集合）：
       
     排行榜应用，取TOP N操作

这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，
这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，
每次只需要执行一条ZADD命令即可。   
```

### 6.4 发布订阅

```
窗口1：

127.0.0.1:6379> SUBSCRIBE baodi 

窗口2：

127.0.0.1:6379> PUBLISH baodi "jin tian zhen kaixin!"

订阅多频道：
窗口1：
127.0.0.1:6379> PSUBSCRIBE wang*
窗口2：
127.0.0.1:6379> PUBLISH wangbaoqiang "jintian zhennanshou "
```

## 7. 事物

```
redis的事务是基于队列实现的。

mysql的事务是基于事务日志实现的。binlog文件


redis开启事物(multi)：
    multi 
    command1 (语句)     
    command2
    command3
    command4
    
4条语句作为一个组，并没有真正执行，而是被放入同一队列中。
如果，这时执行discard，会直接丢弃队列中所有的命令，而不是做回滚。

discard: 会直接丢弃队列中所有的命令，而不是做回滚。
   
exec：当执行exec时，对列中所有操作，要么全成功要么全失败

例子：
   ----------
127.0.0.1:6379> set a b
OK
127.0.0.1:6379> MULTI
OK
127.0.0.1:6379> set a b
QUEUED
127.0.0.1:6379> set c d
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK

--------------------
```

## 8. redis 乐观锁

```python
# 乐观锁就是没有锁

发布一张票
set ticket 1

窗口1：
watch ticket
multi
set ticket 0       1---->0

窗口2：
multi 
set ticket 0 
exec 

窗口1：
exec
```

## 9.主从复制

```

1、环境：
准备两个或两个以上redis实例

mkdir /data/638{0..2}

配置文件示例：
cat >> /data/6380/redis.conf << EOF 
port 6380
daemonize yes
pidfile /data/6380/redis.pid
loglevel notice
logfile "/data/6380/redis.log"
dbfilename dump.rdb
dir /data/6380
requirepass 123
masterauth 123
EOF

cp /data/6380/redis.conf /data/6381/redis.conf
cp /data/6380/redis.conf /data/6382/redis.conf

sed -i 's#6380#6381#g' /data/6381/redis.conf
sed -i 's#6380#6382#g' /data/6382/redis.conf


启动：
redis-server /data/6380/redis.conf
redis-server /data/6381/redis.conf
redis-server /data/6382/redis.conf

netstat -lnp|grep 638
 
 
主节点：6380
从节点：6381、6382


2、开启主从：
6381/6382命令行:

redis-cli -p 6381 -a 123 SLAVEOF 127.0.0.1 6380
redis-cli -p 6382 -a 123 SLAVEOF 127.0.0.1 6380


3、查询主从状态
redis-cli -p 6380 -a 123 info replication
redis-cli -p 6381 -a 123 info replication
redis-cli -p 6382 -a 123 info replication


 
4、从库切为主库
   模拟主库故障
redis-cli -p 6380 -a 123 shutdown

redis-cli -p 6381 -a 123
info replication
slaveof no one

6382连接到6381：
[root@db03 ~]# redis-cli -p 6382 -a 123
127.0.0.1:6382> SLAVEOF no one
127.0.0.1:6382> SLAVEOF 127.0.0.1 6381
```

## 10.redis-sentinel（哨兵）

```
作用：
   1、监控
   2、自动选主，切换（6381 slaveof no one）
   3、2号从库（6382）指向新主库（6381）
   4、应用透明
   
配置：

mkdir /data/26380
cd /data/26380

cat >> sentinel.conf << EOF
port 26380
dir "/data/26380"
sentinel monitor mymaster 127.0.0.1 6380 1
sentinel down-after-milliseconds mymaster 5000
sentinel auth-pass mymaster 123 
EOF
启动：
redis-sentinel /data/26380/sentinel.conf &
   
```

## 11. redis cluster

```
高性能：

1、在多分片节点中，将16384个槽位，均匀分布到多个分片节点中
2、存数据时，将key做crc16(key),然后和16384进行取模，得出槽位值（0-16383之间）
3、根据计算得出的槽位值，找到相对应的分片节点的主节点，存储到相应槽位上
4、如果客户端当时连接的节点不是将来要存储的分片节点，分片集群会将客户端连接切换至真正存储节点进行数据存储


高可用：
在搭建集群时，会为每一个分片的主节点，对应一个从节点，实现slaveof的功能，同时当主节点down，实现类似于sentinel的自动failover的功能。

1、redis会有多组分片构成（3组）
2、redis cluster 使用固定个数的slot存储数据（一共16384slot）
3、每组分片分得1/3 slot个数（0-5500  5501-11000  11001-16383）
4、基于CRC16(key) % 16384 ====》值 （槽位号）。


规划、搭建过程：

6个redis实例，一般会放到3台硬件服务器
注：在企业规划中，一个分片的两个分到不同的物理机，防止硬件主机宕机造成的整个分片数据丢失。

端口号：7000-7005

1、安装集群插件
EPEL源安装ruby支持
yum install ruby rubygems -y

使用国内源
gem sources -l
gem sources -a http://mirrors.aliyun.com/rubygems/ 
gem sources  --remove https://rubygems.org/
gem sources -l
gem install redis -v 3.3.3



---
2、集群节点准备

mkdir /data/700{0..5}

cat >> /data/7000/redis.conf << EOF
port 7000
daemonize yes
pidfile /data/7000/redis.pid
loglevel notice
logfile "/data/7000/redis.log"
dbfilename dump.rdb
dir /data/7000
protected-mode no
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
EOF

cp /data/7000/redis.conf /data/7001/redis.conf
cp /data/7000/redis.conf /data/7002/redis.conf
cp /data/7000/redis.conf /data/7003/redis.conf
cp /data/7000/redis.conf /data/7004/redis.conf
cp /data/7000/redis.conf /data/7005/redis.conf

sed -i 's#7000#7001#g' /data/7001/redis.conf
sed -i 's#7000#7002#g' /data/7002/redis.conf
sed -i 's#7000#7003#g' /data/7003/redis.conf
sed -i 's#7000#7004#g' /data/7004/redis.conf
sed -i 's#7000#7005#g' /data/7005/redis.conf

启动节点：

redis-server /data/7000/redis.conf 
redis-server /data/7001/redis.conf 
redis-server /data/7002/redis.conf 
redis-server /data/7003/redis.conf 
redis-server /data/7004/redis.conf 
redis-server /data/7005/redis.conf 


 ps -ef |grep redis
 
 就可以插入数据了。会将数据保存到任意一个节点上
```

## 12. redis-api

```
python为例

# 安装python:
 tar xf Python-3.5.2.tar.xz 
 cd  Python-3.5.2
./configure
make && make install



redis的安装：
https://redis.io/clients

下载redis-py-master.zip

unzip redis-py-master.zip

cd redis-py-master
python3 setup.py install


安装redis-cluser的客户端程序
 cd redis-py-cluster-unstable
 python3 setup.py install
```

### 12.1  对redis额的单实例进行连接操作

```
python3
>>>import redis
>>>r = redis.StrictRedis(host='10.0.0.200', port=6379, db=0,password='123')
>>>r.set('foo', 'bar')
True
>>>r.get('foo')
'bar'
```

### 12.2 sentinel集群连接并操作

```
[root@db01 ~]# redis-server /data/6380/redis.conf
[root@db01 ~]# redis-server /data/6381/redis.conf
[root@db01 ~]# redis-server /data/6382/redis.conf 
[root@db01 ~]# redis-sentinel /data/26380/sentinel.conf &

## 导入redis sentinel包
>>>from redis.sentinel import Sentinel  
##指定sentinel的地址和端口号
>>> sentinel = Sentinel([('localhost', 26380)], socket_timeout=0.1)  
##测试，获取以下主库和从库的信息
>>> sentinel.discover_master('mymaster')  
>>> sentinel.discover_slaves('mymaster')  
```

## 12.3 Python连接rediscluster集群测试使用

```
python3
>>> from rediscluster import StrictRedisCluster  
>>> startup_nodes = [{"host": "127.0.0.1", "port": "7000"},{"host": "127.0.0.1", "port": "7001"},{"host": "127.0.0.1", "port": "7002"}]  
### Note: decode_responses must be set to True when used with python3  
>>> rc = StrictRedisCluster(startup_nodes=startup_nodes, decode_responses=True)  
>>> rc.set("foo0000", "bar0000")  
True  
>>> print(rc.get("foo0000"))  
'bar'
```

## 13 . 概念性的问题

```
缓存穿透
概念
访问一个不存在的key，缓存不起作用，请求会穿透到DB，流量大时DB会挂掉。

解决方案
采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；
访问key未在DB查询到值，也将空值写进缓存，但可以设置较短过期时间。

缓存雪崩
概念
大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。

解决方案
可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效。

缓存击穿
概念
一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

解决方案
在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

```

