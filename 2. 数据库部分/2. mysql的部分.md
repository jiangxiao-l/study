# mysql部分

## 1. mysql的前景及简单的介绍

```
1. 查看数据的走势：
https://db-engines.com/en/ranking

2. MongoDB --> 爬虫的数据
```

## 2. mysql的版本

```
最新： oracal mysql 8.0 
主流版本：
       mysql 5.6 ———> 5.6.36  5.6.38  5.6.40  
       mysql 5.7 ---> 5.7.18  5.7.20  5.7.22 
公认的最稳定的版本：5.7.20
企业版本选择：6-12月之间的GA（GA:稳定的发布版本,用双数的） 
```

## 3.mysql 的体系结构

### 3.1 MySQL的 C/S结构

```
两种链接方法: TCP/IP (远程,本地),SOCKET(本地)
	
  mysql -uroot -poldboy123 -h 10.0.0.200 -P3306
  mysql -uroot -poldboy123 -S /tmp/mysql.sock	
```

### 3.2 MySQL实例

```
实例=mysqld+内存结构
MySQL实例======>	 mysqld(董事长)---->master thread(经理)---->N Thread(员工)  ------>内存结构(办公区)
```

### 3.3 mysqld三层结构

```python
#1. 连接层：
    1.提供连接协议(TCP ,Socket)
    2.用户验证
    3.提供专用链接线程

# 2. SQL层：
1.接收上层的命令
2.语法检测
3.语义(SQL类型),权限
SQL类型:DDL数据定义语言   DCL数据控制语言    DML数据操作语言     DQL数据查询
4.专用解析器解析SQL,解析成多种执行计划
5.优化器:帮我们选择一个代价最低的执行计划(cpu,IO,MEM)
6.执行器:按照优化器的选择,执行SQL语句,得出获取数据方法
7.查询缓存:默认是关闭的.   一般会使用redis产品替代      Tair
8.记录日志:二进制日志

# 3. 存储引擎层：
   按照SQL层结论,找相应数据,结构化成表的形式
```

## 4. MySQL的逻辑结构

```
库(schema):存储表的地方(库名,属性)
表(Table):二维表

	元数据
		表名字
		表的属性(表的大小,权限,存储引擎,字符集等)
		列:列名字,列属性(数据类型,约束,其他定义)
==============================================	
		记录:数据行
==============================================
```

## 5. SQL 语句(SQL92）

### 5.1 SQL 种类

```python
# DDL： 数据定义语言   
# DCL： 数据控制语言    
# DML： 数据操作语言     
# DQL： 数据查询语言
```

### 5.2 SQL语句的操作对象

```Python
# 库   表
```

### 5.3 不同分类语句作用

```
DDL :   
	库
	CREATE DATABASE
	DROP   DATABASE
	ALTER  DATABSE
	
	SQL语句规范第一条:
	CREATE DATABASE oldboy CHARSET utf8mb4;
	1.关键字大写(非必须),字面量小写(必须)
	2.库名字,只能是小写,不能有数字开头,不能是预留关键字
	3.库名字必须和业务名有关,例如his_user;
	4.必须加字符集.

	表
	CREATE TABLE 
	DROP   TABLE
	ALTER  TABLE
	
CREATE TABLE t1 (
id  INT NOT NULL PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
sname  VARCHAR(20) NOT NULL COMMENT '用户姓名',
gender ENUM('f','m','u') NOT NULL DEFAULT 'u' COMMENT '用户性别',
telnum CHAR(11) NOT NULL UNIQUE COMMENT '手机号',
tmdate DATETIME NOT NULL DEFAULT NOW() COMMENT '录入时间'
)ENGINE INNODB CHARSET utf8mb4;

	SQL语句规范第二条:
	1.关键字大写(非必须),字面量小写(必须)
	2.表名必须小写,不能有数字开头,不能是预留关键字
	3.表名字必须和业务名有关
	4.必须加存储引擎和字符集
	5.适合的数据类型
	6.必须要有主键
	7.尽量非空选项
	8.字段唯一性
	9.必须加注释
	10.避免使用外键
	11.建立合理的索引

DCL:
	grant
	revoke
	lock
	
DML : 
	insert
	update
	delete 
	
	SQL语句规范第三条:
	1.insert语句按批量插入数据
	2.update必须加where条件
	3.delete尽量替换为update
	4.如果有清空全表需求,不要用delete,推荐使用truncate 
	
DQL :
		select 
		show 
		
SQL语句规范第四条:	
		1. select语句避免使用 select *  from  t1; ---->  select id,name from t1;
		2. select语句尽量加等值的where条件.例如 select * from t1 where id=20;
		3. select 语句对于范围查询,例如 ;select * from t1 where id>200; 尽量添加limit或者  id>200 and id<300 union all id>300 and id<400
		4. select 的where 条件  不要使用 <>  like '%name'  not in  not exist 
		5. 不要出现3表以上的表连接,避免子查询
		6. where条件中不要出现函数操作.
		
```

## 6. MySQL5.7 版本的配置

### 6.1 数的初始化

```python
/usr/local/mysql/bin/mysqld --initialize-insecure  --user=mysql --datadir=/opt/mysql/data --basedir=/opt/mysql
```

### 6.2 配置文件

```
vim /etc/my.cnf
[mysqld]
basedir=/opt/mysql           --> （与具体的安装路径有关）
datadir=/opt/mysql/mydata     --> (与具体的安装路径有关)
socket=/tmp/mysql.sock
log_error=/var/log/mysql.log
user=mysql
port=6606
[mysql]
socket=/tmp/mysql.sock
```

### 6.3 作用

```
作用:
1.影响服务端的启动
标签: [mysqld]   [mysqld_safe]  [server] ...
	[mysqld]
    basedir=/opt/mysql              
    datadir=/opt/mysql/data
    user=mysql
    socket=/tmp/mysql.sock
    port=3306 
    server_id=6

2.影响客户端连接
标签: [client]   [mysql]  [mysqldump] ....
[mysql] 
socket=/tmp/mysql.sock  --> 客户点连接的相关文件
```

## 7. 多实例的创建

### 7.1  创建相关的目录

```Python
mkdir -p /data/330{7..9}/data   --> 存放数据的文件夹
```

### 7.2 创建配置文件

```python
cat>> /data/3307/my.cnf<<EOF
[mysqld]
basedir=/opt/mysql              
datadir=/data/3307/data   --> 数据文件
user=mysql
socket=/data/3307/mysql.sock  --> 客户端连接有关的文件
port=3307 
server_id=3307
EOF

# 复制已经写好的配置文件，并进行简单的修改。

cp /data/3307/my.cnf /data/3308 
cp /data/3307/my.cnf /data/3309 

sed -i 's#3307#3308#g' /data/3308/my.cnf 
sed -i 's#3307#3309#g' /data/3309/my.cnf 
```

### 7.3 初始化数据

```python
mysqld --initialize-insecure  --user=mysql --datadir=/data/3307/data --basedir=/opt/mysql

mysqld --initialize-insecure  --user=mysql --datadir=/data/3308/data --basedir=/opt/mysql

mysqld --initialize-insecure  --user=mysql --datadir=/data/3309/data --basedir=/opt/mysql
```

### 7.4 多实例的启动

```python
 #1.  权限的授予： chown -R mysql.mysql /data/*

# 2. 实例的启动：mysql_safe

 mysqld_safe --defaults-file=/data/3307/my.cnf &
 mysqld_safe --defaults-file=/data/3308/my.cnf &
 mysqld_safe --defaults-file=/data/3309/my.cnf &
```

### 7.5  测试

```python
 # 命令： netstat -lnp|grep 330

 # 连接：其实就是 mysql 一般后面省略了—S....后面的内容
 mysql -S /data/3307/mysql.sock
 mysql -S /data/3308/mysql.sock
 mysql -S /data/3309/mysql.sock
```

### 7.6 利用systemctl 来管理mysql

```python 
# 1.配置文件的配置：
cat >> /etc/systemd/system/mysqld3307.service <<EOF
[Unit]
Description=MySQL Server
Documentation=man:mysqld(8)
Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html
After=network.target
After=syslog.target
[Install]
WantedBy=multi-user.target
[Service]
User=mysql
Group=mysql
ExecStart=/opt/mysql/bin/mysqld --defaults-file=/data/3307/my.cnf
LimitNOFILE = 5000
EOF

# 2.拷贝配置文件
  cp  /etc/systemd/system/mysqld3307.service              /etc/systemd/system/mysqld3308.service 
    
cp  /etc/systemd/system/mysqld3307.service   /etc/systemd/system/mysqld3309.service 

# 3. 对配置文件进行修改
sed -i 's#3307#3308#g'   /etc/systemd/system/mysqld3308.service
sed -i 's#3307#3309#g'   /etc/systemd/system/mysqld3309.service
```

### 7.7 在systemctl下的测试

```python
 # 开启：
 systemctl start mysqld3307
 systemctl start mysqld3308
 systemctl start mysqld3309
    
 #关闭： 
 netstat -lnp|grep 330
 systemctl stop mysqld3309
 systemctl stop mysqld3308
 systemctl stop mysqld3307
 
 # 设置开机自启：
 systemctl enable  mysqld3307
 systemctl enable  mysqld3308
 systemctl enable  mysqld3309
```

## 8. 忘记密码的处理

```python
#前期的测试：先登入观看mysql.user表的结构：
mysqladmin -uroot -p password 123
select user,authentication_string,host from mysql.user;

# 1.停数据库
/etc/init.d/mysqld stop

# 2.启动数据库为无密码验证模式：--skip-networking（禁止远程连接）
mysqld_safe --skip-grant-tables --skip-networking  &

# 3.修改密码：
update mysql.user set authentication_string=PASSWORD('456') where user='root' and host='localhost';

#4. 重启：
/etc/init.d/mysqld restart

#5. 登入：
mysql -uroot -p456




```

## 9. 索引及执行计划

### 9.1 索引

```
作用: 优化查询,select 查询有三种情况:缓存查询(不在mysql中进行数据查询),全表扫描,索引扫描
```

### 9.2 索引的种类

```mysql
Btree(btree  b+tree b*tree)
Rtree
HASH
FullText 
```

### 9.3 Betree 分类

```python
聚集索引:基于主键,自动生成的,一般是建表时创建主键.如果没有主键,自动选择唯一键做为聚集索引.

辅助索引:人为创建的(普通,覆盖)

唯一索引:人为创建(普通索引,聚集索引)

# 聚集索引和辅助索引的对比：
1.聚集索引:叶子结点,按照主键列的顺序,存储的整行数据,就是真正的数据页
2.辅助索引: 叶子结点,列值排序之后,存储到叶子结点+对应的主键的值,便于回表查询


```

### 9.4  索引管理命令

```python 
# 辅助索引(BTREE)
怎么生成的:
根据创建索引时,指定的列的值,进行排序后,存储的叶子节点中
# 好处:
1.优化了查询,减少cpu mem IO消耗
2.减少的文件排序
```

#### 9.4.1  创建普通辅助索引(辅助索引)

```mysql
alter table blog_userinfo add key(index) idx_email(email);

create index(key) idx_phone on blog_userinfo(phone);
```

#### 9.4.2  索引的查看

```mysql
desc blog_userinfo;

show index from blog_userinfo;
```

#### 9.4.3 索引的删除

```mysql
alter table blog_userinfo drop index(key) idx_email;

drop index(key) idx_phone on   blog_userinfo;
```

#### 9.4.4  前缀索引

```mysql
select count(*),substring(password,1,20) as sbp  from blog_userinfo group by sbp;

alter table blog_userinfo add index idx(password(10));
```

#### 9.4.5  唯一索引(UNI，如果有重复创建的值是创建不了的 )

```mysql
alter table blog_userinfo add unique key uni_email(email);
```

#### 9.4.6 覆盖索引

```python
作用： 不需要会表查询，不需要聚集索引，所以查询的数据从辅助索引中获取，减少回表查询的几率。

alter table t1 add index idx_gam(gender,age,money);
```

## 10 . explain(desc) 命令的使用

```python 
# 获取优化器选择后的执行计划

# 用法:就是在执行的语句前面加上explain(desc)

例子：explain select * from city where countrycode='CHN'\G
```

### 10.1  重要字段的解析

#### 10.1.1  type: 查询类型（重点）

```python 
# 作用:
	1. 可以判断出,全表扫描还是索引扫描(ALL就是全表扫描,其他的就是索引扫描)
	2. 对于索引扫描来讲,又可以细划分,可以判断是哪一种类的索引扫描
    
 

type的具体类型介绍:
    
	# ALL:全表扫描 
	 select  *  from  t1;
    
    
	# Index:全索引扫描
		例子:
		desc select countrycode from city ;
        
		
    #range:索引范围扫描
		where > <  >= <= (不包含 not in 不等于) 
		in   or   between and 
		like 'CH%'
		
	    in 或者 or 改写成 union	可以提高效率
        select * from city where countrycode='CHN'
        union all 
        select * from city where countrycode='USA';

	# ref:辅助索引的等值查询
	  select * from city where countrycode='CHN'
	
	# eq_ref: 多表链接查询(join on )
	
	# const ,system :主键或唯一键等值查询
    
    
    注：查询效率依次增加
```

#### 10.1.2  EXtra

```Python
  # using  filesort:    文件排序(重点，连面试官都可能不知道的) 会降低数据的查询效率
    
  # 解决方式：建立联合索引
    
  将order by  group by  distinct 后的列和where条件列建立联合索引
  
```

#### 10.1.3  其他的字段

```
possible_keys: CountryCode,idx_co_po      ---->可能会走的索引
key: CountryCode						  ---->真正走的索引
type: ref								  ---->索引类型
Extra: Using index condition              ---->额外信息

```

## 11 . 不走索引的情况(开发的规范)

```mysql
1) 重点关注： 没有查询条件，或者查询条件没有建立索引 (尽量避免*的查询)

select * from tab;   全表扫描。
select  * from tab where 1=1;

在业务数据库中，特别是数据量比较大的表。是没有全表扫描这种需求。

1、对用户查看是非常痛苦的。
2、对服务器来讲毁灭性的。

（1）select * from tab;

SQL改写成以下语句：
selec  * from tab  order by  price  limit 10      需要在price列上建立索引


（2）
select  * from  tab where name='zhangsan'          name列没有索引

改：
	1、换成有索引的列作为查询条件
	2、将name列建立索引


	
	
# 2) 查询结果集是原表中的大部分数据，应该是25％以上。 

查询的结果集，超过了总数行数25%，优化器觉得就没有必要走索引了。

假如：tab表 id，name    id:1-100w  ，id列有索引

select * from tab  where id>500000;

如果业务允许，可以使用limit控制。

怎么改写 ？
结合业务判断，有没有更好的方式。如果没有更好的改写方案
尽量不要在mysql存放这个数据了。放到redis里面。


3) 索引本身失效，统计数据不真实 
索引有自我维护的能力。
对于表内容变化比较频繁的情况下，有可能会出现索引失效。


4) 查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等) 
例子： 
错误的例子：select * from test where id-1=9; 
正确的例子：select * from test where id=10;

算术运算
函数运算
desc select  *   from blog_userinfo  where DATE_FORMAT(last_login,'%Y-%m-%d') >= '2019-01-01';

子查询

# 5)隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误. 

select * from t1 where telnum=110;


这样会导致索引失效. 错误的例子：
------------------------
mysql> alter table tab add index inx_tel(telnum);
Query OK, 0 rows affected (0.03 sec)
Records: 0  Duplicates: 0  Warnings: 0


mysql> desc tab; 
 注：telnum为字符串的格式
 错误的写法：select * from tab where telnum=1333333;
 正确的写法：select * from tab where telnum ='12222'
 
6) 
<>  ，not in 不走索引

EXPLAIN SELECT * FROM teltab WHERE telnum   <> '110';
EXPLAIN  SELECT * FROM teltab WHERE telnum  NOT IN ('110','119');
------------
mysql> select * from tab where telnum <> '1555555';
+------+------+---------+
| id   | name | telnum  |
+------+------+---------+
|    1 | a    | 1333333 |
+------+------+---------+
1 row in set (0.00 sec)

mysql> explain select * from tab where telnum <> '1555555';


-----
单独的>,<,in 有可能走，也有可能不走，和结果集有关，尽量结合业务添加limit
or或in  尽量改成union

EXPLAIN  SELECT * FROM teltab WHERE telnum   IN ('110','119');
改写成：

EXPLAIN SELECT * FROM teltab WHERE telnum='110'
UNION ALL
SELECT * FROM teltab WHERE telnum='119'

-----------------------------------
7)   like "%_" 百分号在最前面不走

EXPLAIN SELECT * FROM teltab WHERE telnum LIKE '31%'   走range索引扫描

EXPLAIN SELECT * FROM teltab WHERE telnum LIKE '%110'  不走索引


%linux%类的搜索需求，可以使用elasticsearch 专门做搜索服务的数据库产品


8) 单独引用联合索引里非第一位置的索引列.作为条件查询时不走索引.
列子：
复合索引：

DROP TABLE t1
CREATE TABLE t1 (id INT,NAME VARCHAR(20),age INT ,sex ENUM('m','f'),money INT);

ALTER TABLE t1 ADD INDEX t1_idx(money,age,sex);

DESC t1
SHOW INDEX FROM t1

走索引的情况测试：
EXPLAIN SELECT NAME,age,sex,money FROM t1 WHERE money=30 AND age=30  AND sex='m';
EXPLAIN SELECT NAME,age,sex,money FROM t1 WHERE money=30 AND age=30  ;
EXPLAIN SELECT NAME,age,sex,money FROM t1 WHERE money=30  AND sex='m';    ----->部分走索引
不走索引的：
EXPLAIN SELECT  NAME,age,sex,money FROM t1 WHERE  age=20
EXPLAIN SELECT NAME,age,sex,money FROM t1 WHERE  age=30  AND sex='m';
EXPLAIN SELECT NAME,age,sex,money FROM t1 WHERE   sex='m';


 
```

##  12. 存储引擎

### 12.1 作用

```
和磁盘的数据打交道
```

### 12.2  简介

```
MySQL 基于存储引擎管理 表空间数据文件

数据的存储引擎：存储数据的核心代码
```

### 12.3    种类

```
innodb 存储引擎

ibd:存储表的数据行和索引

frm： 表的基本结构信息

Myiscam:存储引擎

```

### 12.4  innodb  存储引擎的核心特征 --> 事物

```Python
# 事物：在MySQL中事物是一些语句的集合，他们是原子性的，要么全部执行成功，要么全部不执行。

# 事物的特征：ACID
Acomic(原子性)： 所有语句作为单元全部成功执行或则全部取消，不允许出现中间过程。
Consistent(一致性)：如果数据在事物开始处于一致状态，则在执行事物的期间将保留一致状态
Isolated（隔离型）：事物之间不相互影响，两各方面：修改同一行，一致性读：所有的数据都是完整的。
Durable（持久性）： 事物成功完成后，所做的所有的更改都会准确记录在数据中。所做的更改不会丢失。


redo  undo 实现了 ACD

I：行级锁： 事物修改行，会锁定这行(持有这行的锁)


# 事物的隔离级别：
    （1）：提交未读 RU
    （2）: 读已提交 RC
    （3）：可重复读 RR
    （4）：可串行化 S
   
  
# 事物的控制语句：
   begin(statr);
       xxxxx
        xxxxx
    commit;
  
  # 隐士提交：
    	短暂： set autocommit = 0;
        永久：配置文件：my.cnf --> autocommit =0；
        
         
```



##  13 . 日志

### 13.1   错误日志

```
配置文件里配置：my.cnf --> /var/log/mysql.log
```

### 13.2  二进制日志(binlog 逻辑型日志)

```mysql
1. 作用： 
      记录所有变更类的语句
      DDL，DCL:以语句方式(statement)记录
      DML(已经提交的事物语句)：默认是已行模式记录(row模式,数据行的变化)
      可以做数据恢复和操作的审计
      
2. 配置方法：配置文件my.cnf 添加以下语句： 
  	
  	log_bin = /opt/mysql/data/mysql-bin
  	binlog_format =row
  	server_id = 6
    sync_binlog=1 

3. 查看日志信息：
	show binary logs;
	show master status;
	
4. 查看日志内容：
   按事件查看日志内容：show binlog events in 'mysql-bin.0.00012'
   直接查看日志内容： mysqlbinlog --base64-output=decode-rows-vvv /opt/mysql/data/mysql-bin.000012|more
   
  
5. 截取二进制日志：
     mysqlbinlog --srart-postion=219 --stop-postion =123123 /opt/mysql/data/mysql-bin.000012>/tmp/binlog.sql
     

```

### 13.3 慢日志(show-log)

```mysql
记入慢日志的日志文件：--> 就是记录一些不够优化的查询语句(查询时间比较长的)
 slow_query_log =1
 slow_query_log_file = /opt/mysql/data/standby-slow.log
 long_quey_timw =1 
 log_queries_not_using_indexes=1
 

使用 Box Anemometer基于pt-query-digest将MySQL的慢查询可视化
```

## 14  备份恢复

### 14.1 备份的种类

```
备份的种类：
  逻辑备份：SQL语句的备份
  物理备份：数据页的备份
```

### 14.2  逻辑备份工具的介绍

```
select xxxx from t1 into outfile '/temp/redis.text'

 mysql -uroot -p123 -e "select concat('hmset city_',id,' id ', id,' name ',name,' countrycode ',countrycode,' district ',district,' population ',population) from world.city limit 10 "|redis-cli	
 
 mysqldump
 -u
 -p
 -S
 -h
 -P

-A: 全库备份
mysqldump-uroot -p123 -A > /backup/full.sql

-B 备份一个或则多个指定的库：world(库名) bbs(库名)
mysqldump -uroot -p123 -B world bbs >/backup/wb.sql

备份单库中的表：world(库名) city(表名) country(表名)
mysqldump -uroot -p1234 world city country >/backup/cc/sql


--master-data =2  备份是记录二进制日志的状态
--single-transation 开启innodb 热备份功能
-R 
--triggles

mysqldump -uroot -p123 -A --master-data=2 --single-transation -R --triggers >/backup/full.sql
```

## 15  主从复制

```
#  基于二进制日志完成的

master(主的数据库) -- slave(从的数据库)
3307      				3308

1. 3307数据库中创建复制用户
主库开启二进制日志：vim /data/3307/my.cnf  --> log_bin=/data/3307/mysql-bin

2.开启主的数据库： systemctl start mysqld3307(mysql -S /data/3307/mysql.sock )

3.创建用户: grant replication slave on *.* repl@'10.0.0.%' indentified by '123';

4.查看状态：show master status

+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      154 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+


5.开启从数据库： mysql -S /data/3308/mysql.sock

6.在从数据库中开启主重复制功能:
      CHANGE MASTER TO
      MASTER_HOST='10.0.0.200',
  	  MASTER_USER='repl',
  	  MASTER_PASSWORD='123',
  	  MASTER_PORT=3307,
      MASTER_LOG_FILE='mysql-bin.000001',
      MASTER_LOG_POS=154;
      
 7.开启服务：start slave
 
 8. 查看状态： show slave status\G
 		
 		Slave_IO_Running: Yes
		Slave_SQL_Running: Yes
 

```

## 16  mysql 高可用架构的介绍

```
MHA  
	5.7 MGR+Mysql router+mysql shell.....===>Mysql Innodb Cluster    ======>mongodb sharding cluster
	
    PXC      
	galera cluster
```

## 17 高性能架构

```
读写分离
	
		atlas  360   C++
		maxscale mariadb
		proxySQL  
			Mycat 
			DBLE 
			TDDL
			DRDS 
```

